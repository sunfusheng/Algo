package com.wangcheng.leetcode.LeetCode.Number;

import com.sunfusheng.algo.common.util.LeetCodeUtil;

/**
 *【题目】
 * 190.颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。
 *【示例】
 * 示例 1：
 * 输入: 00000010100101000001111010011100
 * 输出: 00111001011110000010100101000000
 * 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
 *       因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 *
 * 示例 2：
 * 输入：11111111111111111111111111111101
 * 输出：10111111111111111111111111111111
 * 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
 *       因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
 *
 *【提示】
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。
 * 在这种情况下，输入和输出都将被指定为有符号整数类型，
 * 并且不应影响您的实现，因为无论整数是有符号的还是无符号的，
 * 其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。
 * 因此，在上面的 示例 2 中，输入表示有符号整数 -3，
 * 输出表示有符号整数 -1073741825。
 *
 * @author liwangcheng
 * @date 2020/4/10.
 */
public class ReverseBits {

    /**
     * 方法一：逐位颠倒
     * 关键思想是：
     * 对于位于索引 i 处的位，在反转之后，其位置应为 31-i（注：索引从零开始）。
     * 从右到左遍历输入整数的位字符串（即 n=n>>1）。
     * 要检索整数的最右边的位，应用与运算（n&1）。
     * 对于每个位，将其反转到正确的位置（即（n&1）<<power）。
     * 然后添加到最终结果。当 n==0 时，终止迭代。
     *
     * 复杂度分析
     * 时间复杂度：O(log2N)。在算法中，有一个循环来迭代输入的最高非零位，即log2N。
     * 空间复杂度：O(1)，因为不管输入是什么，内存的消耗是固定的。
     */
    public static int solution1(int n) {
        int ret = 0;
        int power = 31;
        while (n != 0) {
            ret += (n&1)<<power;
            n = n>>1;
            power--;
        }
        return ret;
    }

    /**
     * TODO
     * 方法二：分治
     * 通过掩码将 32 位整数划分成具有较少位的块，
     * 然后通过将每个块反转，最后将每个块的结果合并得到最终结果。
     *
     * 算法：
     * 首先，将原来的 32 位分为 2 个 16 位的块。
     * 然后将 16 位块分成 2 个 8 位的块。
     * 然后继续将这些块分成更小的块，直到达到 1 位的块。
     * 在上述每个步骤中，将中间结果合并为一个整数，作为下一步的输入。
     *
     * 复杂度分析
     * 时间复杂度：O(1)，没有使用循环。
     * 空间复杂度：O(1)，没有使用变量。
     */
    public static int solution2(int n) {
        n = ((n & 0xffff0000) >>> 16) | ((n & 0x0000ffff) << 16);
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        return n;
    }

    /**
     * 方法三：
     * 思路：
     * 用一个变量 res 去存储结果，依次得到要转换数字的低位，然后依次保存到 res 中。
     * res 每得到一位后进行左移腾出位置保存下一位。
     * 参考：
     * https://leetcode-cn.com/problems/reverse-bits/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-4-9/
     * 说明：
     * 把n的二进制表示当成一个数组，依次读出数组中每一位的值放到临时数组的对应位置即可
     */
    public static int solution3(int n) {
        int res = 0;
        int count = 0;
        while (count < 32) {
            // res 左移一位空出位置
            res <<= 1;
            // 得到的最低位加过来
            res |= (n & 1);
            // 原数字右移一位去掉已经处理过的最低位
            n >>= 1;
            count++;
        }
        return res;
    }

    public static void main(String[] args) {
        LeetCodeUtil.logln("solution1(00000010100101000001111010011100) = " + ReverseBits.solution1(43261596));
        LeetCodeUtil.logln("solution2(00000010100101000001111010011100) = " + ReverseBits.solution2(43261596));
        LeetCodeUtil.logln("solution3(00000010100101000001111010011100) = " + ReverseBits.solution3(43261596));
    }
}
